"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
const core_1 = require('@angular/core');
const cache_storage_abstract_service_1 = require('./storage/cache-storage-abstract.service');
const cache_session_storage_service_1 = require('./storage/session-storage/cache-session-storage.service');
const cache_local_storage_service_1 = require('./storage/local-storage/cache-local-storage.service');
const cache_memory_service_1 = require('./storage/memory/cache-memory.service');
const CACHE_PREFIX = 'CacheService';
const DEFAULT_STORAGE = 1 /* SESSION_STORAGE */;
const DEFAULT_ENABLED_STORAGE = 2 /* MEMORY */;
let CacheService = class CacheService {
    constructor(_storage) {
        this._storage = _storage;
        /**
         * Default cache options
         * @type CacheOptionsInterface
         * @private
         */
        this._defaultOptions = {
            expires: Number.MAX_VALUE,
            maxAge: Number.MAX_VALUE
        };
        /**
         * Cache prefix
         */
        this._prefix = CACHE_PREFIX;
        this._validateStorage();
    }
    /**
     * Set data to cache
     * @param key
     * @param value
     * @param options
     */
    set(key, value, options) {
        let storageKey = this._toStorageKey(key);
        options = options ? options : this._defaultOptions;
        this._storage.setItem(storageKey, this._toStorageValue(value, options));
        if (!this._isSystemKey(key) && options.tag) {
            this._saveTag(options.tag, storageKey);
        }
    }
    /**
     * Get data from cache
     * @param key
     * @returns {any}
     */
    get(key) {
        let storageValue = this._storage.getItem(this._toStorageKey(key)), value = null;
        if (storageValue) {
            if (this._validateStorageValue(storageValue)) {
                value = storageValue.value;
            }
            else {
                this.remove(key);
            }
        }
        return value;
    }
    /**
     * Check if value exists
     * @param key
     * @returns {boolean}
     */
    exists(key) {
        return !!this.get(key);
    }
    /**
     * Remove item from cache
     * @param key
     */
    remove(key) {
        this._storage.removeItem(this._toStorageKey(key));
        this._removeFromTag(this._toStorageKey(key));
    }
    /**
     * Remove all from cache
     */
    removeAll() {
        this._storage.clear();
    }
    /**
     * Get all tag data
     * @param tag
     * @returns {Array}
     */
    getTagData(tag) {
        let tags = this.get(this._tagsStorageKey()) || {}, result = {};
        if (tags[tag]) {
            tags[tag].forEach((key) => {
                let data = this.get(this._fromStorageKey(key));
                if (data) {
                    result[this._fromStorageKey(key)] = data;
                }
            });
        }
        return result;
    }
    /**
     * Remove all by tag
     * @param tag
     */
    removeTag(tag) {
        let tags = this.get(this._tagsStorageKey()) || {};
        if (tags[tag]) {
            tags[tag].forEach((key) => {
                this._storage.removeItem(key);
            });
            delete tags[tag];
            this.set(this._tagsStorageKey(), tags);
        }
    }
    /**
     * Set global cache key prefix
     * @param prefix
     */
    setGlobalPrefix(prefix) {
        this._prefix = prefix;
    }
    /**
     * Validate cache storage
     * @private
     */
    _validateStorage() {
        if (!this._storage) {
            this._initStorage(DEFAULT_STORAGE);
        }
        if (!this._storage.isEnabled()) {
            this._initStorage(DEFAULT_ENABLED_STORAGE);
        }
    }
    /**
     * Remove key from tags keys list
     * @param key
     * @private
     */
    _removeFromTag(key) {
        let tags = this.get(this._tagsStorageKey()) || {}, index;
        for (let tag in tags) {
            index = tags[tag].indexOf(key);
            if (index !== -1) {
                tags[tag].splice(index, 1);
                this.set(this._tagsStorageKey(), tags);
                break;
            }
        }
    }
    /**
     * Init storage by type
     * @param type
     * @returns {CacheStorageAbstract}
     */
    _initStorage(type) {
        switch (type) {
            case 1 /* SESSION_STORAGE */:
                this._storage = new cache_session_storage_service_1.CacheSessionStorage();
                break;
            case 0 /* LOCAL_STORAGE */:
                this._storage = new cache_local_storage_service_1.CacheLocalStorage();
                break;
            default: this._storage = new cache_memory_service_1.CacheMemoryStorage();
        }
    }
    _toStorageKey(key) {
        return this._getCachePrefix() + key;
    }
    _fromStorageKey(key) {
        return key.replace(this._getCachePrefix(), '');
    }
    /**
     * Prepare value to set to storage
     * @param value
     * @param options
     * @returns {{value: any, options: CacheOptionsInterface}}
     * @private
     */
    _toStorageValue(value, options) {
        return {
            value: value,
            options: this._toStorageOptions(options)
        };
    }
    /**
     * Prepare options to set to storage
     * @param options
     * @returns {CacheOptionsInterface}
     * @private
     */
    _toStorageOptions(options) {
        var storageOptions = {};
        storageOptions.expires = options.expires ? options.expires :
            (options.maxAge ? Date.now() + (options.maxAge * 1000) : this._defaultOptions.expires);
        storageOptions.maxAge = options.maxAge ? options.maxAge : this._defaultOptions.maxAge;
        return storageOptions;
    }
    /**
     * Validate storage value
     * @param value
     * @returns {boolean}
     * @private
     */
    _validateStorageValue(value) {
        return value.options.expires > Date.now();
    }
    /**
     * check if its system cache key
     * @param key
     * @returns {boolean}
     * @private
     */
    _isSystemKey(key) {
        return [this._tagsStorageKey()].indexOf(key) !== -1;
    }
    /**
     * Save tag to list of tags
     * @param tag
     * @param key
     * @private
     */
    _saveTag(tag, key) {
        let tags = this.get(this._tagsStorageKey()) || {};
        if (!tags[tag]) {
            tags[tag] = [key];
        }
        else {
            tags[tag].push(key);
        }
        this.set(this._tagsStorageKey(), tags);
    }
    /**
     * Get global cache prefix
     * @returns {string}
     * @private
     */
    _getCachePrefix() {
        return this._prefix;
    }
    _tagsStorageKey() {
        return 'CacheService_tags';
    }
};
CacheService = __decorate([
    core_1.Injectable(),
    __param(0, core_1.Optional()), 
    __metadata('design:paramtypes', [cache_storage_abstract_service_1.CacheStorageAbstract])
], CacheService);
exports.CacheService = CacheService;
//# sourceMappingURL=cache.service.js.map